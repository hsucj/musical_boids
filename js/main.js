
var Main = Main || { };


// called when the gui params change and we need to update mesh
Main.particleSystemChangeCallback = function ( InputSettings ) {

    // Get rid of an old system
    ParticleEngine.stop();
    for ( var i = 0 ; i < ParticleEngine._emitters.length ; ++i ) {
        Scene.removeObject( ParticleEngine.getDrawableParticles( i ) );
    }
    ParticleEngine.removeEmitters();
    ParticleEngine.removeAnimations();

    // Get rid of old models
    Scene.removeObjects();

    // If we specified animated model, then lets load it first
    if ( InputSettings.animatedModelName ) {
        var loader = new THREE.JSONLoader( true );
        loader.load( InputSettings.animatedModelName, InputSettings.animationLoadFunction );
    }

    // Create new system
    var initializer = new InputSettings.initializerFunction ( InputSettings.initializerSettings );

    var updater     = new InputSettings.updaterFunction ( InputSettings.updaterSettings );

    var emitter     = new Emitter( {
        maxParticles:  InputSettings.maxParticles,   // how many particles can be generated by this emitter?
        particlesFreq: InputSettings.particlesFreq,  // how many particle per second will we emit?
        initialize:    initializer,                  // initializer object
        update:        updater,                      // updater object
        material:      InputSettings.particleMaterial,
        cloth:         InputSettings.cloth,
        width:         InputSettings.width,
        height:        InputSettings.height,
    } );

    // If we are not dealing with cloth, lets sort particles
    if ( !InputSettings.cloth ) {
        emitter.enableSorting( Gui.values.sorting );
    }

    ParticleEngine.addEmitter ( emitter );

    // Add new particle system
    ParticleEngine.start();

    // Add the particle system
    for ( var i = 0 ; i < ParticleEngine._emitters.length ; ++i ) {
        Scene.addObject( ParticleEngine.getDrawableParticles( i ) );
    }

    // Create the scene
    InputSettings.createScene();
};
var token = 0;
var boidType = 0;
var song;
var analyzer;
var waveform;
var waveAnalyze;
var fft;
var frameCounter = 0;
var boid_centroid = new THREE.Vector3(0.0, 10.0, 0.0);
var mark = new THREE.Vector3(0.0, 0.0, 0.0);

// when HTML is finished loading, do this
window.onload = function() {
    Student.updateHTML();

    // Setup renderer, scene and gui
    Gui.init( Main.controlsChangeCallback,
              Main.displayChangeCallback );
    Scene.create();

    // Add particle system
    Main.particleSystemChangeCallback( SystemSettings.basic );

    Renderer.create( Scene, document.getElementById("canvas") );

    Renderer.update();

    window.addEventListener( 'keydown', function( event ) {
      // user pressed the enter key
      console.log(event.which);
      if (event.which == 65) {
        mark.x -= 1;
      }
      else if (event.which == 87) {
        mark.y += 1;
      }
      else if (event.which == 83) {
        mark.y -= 1;
      }
      else if (event.which == 68) {
        mark.x += 1;
      }
      else if (event.which == 81) {
        mark.z -= 1;
      }
      else if (event.which == 69) {
        mark.z += 1;
      }
    })

    song = p5.prototype.loadSound('../music/symphony.mp3', function(song) {
      console.log("Song is loaded.");
      console.log(song);
      // song.setVolume(0.5);
      song.play();
    });
    analyzer = new p5.Amplitude();
    analyzer.setInput(song);
    fft = new p5.FFT();
    fft.setInput(song);
    //waveAnalyze = fft.analyze();
    waveAnalyze = fft.waveform();

    //console.log(waveform);
    //console.log(waveAnalyze)
    //console.log("FORM " + waveform);
};
